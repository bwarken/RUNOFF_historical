		CVT10 DOCUMENTATION


	CVT10 IS A TOOL FOR CONVERTING BLISS-10 INTO BLISS-36C.
IT IS WRITTEN IN THE SITBOL VERSION OF SNOBOL AND CURRENTLY RUNS
ON THE BLISS GROUP'S DECSYSTEM-10.  ANOTHER VERSION, CALLED CVT11,
CONVERTS BLISS-11 TO BLISS-16C.  CVT10 IS DESIGNED TO DO A LARGE
PERCENTAGE OF THE SYNTAX CONVERSIONS AND SOME SMALLER SET OF
OTHER CONVERSIONS.  SINCE CVT10 IS NOT A LANGUAGE PROCESSOR, IT
IS LIMITED IN THE COMPLETENESS OF TRANSLATION AS WELL AS THE 
NUMBER OF WAYS CERTAIN LEGAL CONSTRUCTS CAN WRITTEN AND STILL
GET TRANSFORMED.  CVT10 ASSUMES THAT THE INPUT COMPILES WITH THE
BLISS-10 COMPILER, ALSO, IT MAKES NO PROVISIONS FOR EXPANDING
MACROS IN ORDER TO SEE WHAT WAS MEANT.  'REASONABLE' MACROS AND
'REASONABLE' CODE WILL GO THROUGH CVT10 FAIRLY WELL.

	TO USE CVT10 DO: RU CVT10  (ON THE APPROPRIATE PPN)

	CVT10 WILL ASK FOR THE NAMES OF THE INPUT FILES
	SEPARATED BY SPACES, SPACES IN THE FILE NAME WILL
	CAUSE AN ERROR.  THE OUTPUT FILES ARE THEN ASKED
	FOR, THE DEFAULT IN BOTH CASES IS TTY:.  WHEN ALL
	OF THE FILES HAVE BEEN CONVERTED, CVT10 WILL ASK
	FOR ANOTHER SET OF INPUT FILES AND OUTPUT FILES.


	THE FOLLOWING IS A COMPLETE LIST OF THE CONSTRUCTS
AND KEYWORDS, AND CHARACTER TRANSLATIONS THAT CVT10 KNOWS
ABOUT.  THE DESIGN DOCUMENTATION, PARTICULARLY THE SECTION
FOR THE TITLE OF EACH TRANSFORM WILL PROVIDE ADDITIONALLY
INFORMATION IF IT IS NEEDED.  THE DETAILED DESCRIPTION AT
THE END, THE SECTION ON CHANGING THE SOURCE CODE, AND THE
DOCUMENTATION ON THE BUILTIN DEBUGGING AIDS ARE WRITTEN FOR
SOMEONE WHO KNOWS SOME SNOBOL AND WANTS TO FIX A BUG OR ADD
A TRANSFORMATION.  THE PROGRAM SOURCE IS ALSO DOCUMENTED.
		SUMMARY OF TRANSFORMATIONS

		<TRANSLATIONS>
DOLLAR SIGNS AT END OF MACROS TO PERCENT SIGNS. (WITH %QUOTE).
UNDERSCORES TO EQUALSIGN, AT-SIGN(@) TO DOT. (X_@Y -> X=.Y).

REPLACEMENT OF KEYWORDS - RADIX50 -> %RAD50_10
REGULAR KEYWORDS: ASCII, ASCIZ, RADIX50, SIXBIT,
WARNINGS: COPY, EXIT, FIRSTONE, GLOBALLY, INCP, INDEXES,
NAMES, NOVALUE, OFFSET, VREG.

OCTAL CONSTANTS TO NEW SYNTAX - #6243 -> %O'6243'
POINTY BRACKETED EXPRESSION IN CERTAIN CASES
HANDLE COMMENTS, QUOTED STRINGS, SPECIAL IDENTIFIERS

		<PSEUDO-OPS>
!CVTCOM - COMMENT OUT BLISS-10 CODE, UNDONE BY !MOCTVC
!CVTTEXT - REMOVE COMMENT CHAR FROM TEXT, UNDONE BY !TXETTVC

		<DECLARATIONS>
BIND, EXTERNAL, FORWARD, GLOBAL, GLOBAL BIND, GLOBAL ROUTINE, LOCAL
MACHOP, MACRO, MAP, OWN, REGISTER, REQUIRE, STACKLOCAL, SWITCHES.

		<CONSTRUCTS>
	MODULE HEADER, CASE, SELECT.
		BASIC STRATEGY FOR CONVERSION

<LABEL>			<ACTION TAKEN>

CTLOOP	DETERMINE IF THE TEXT IS A COMMENT OR A QUOTED
	STRING OR A NAME LITERAL(?..JDAT), IF IT IS,
	THEN PROCESS IT WITH THE APPROPRIATE SECTION.
	IF NOT, GO TO THE 'REGULAR' TEXT SECTION FOR
	SIMPLE TRANSLATIONS, AND THEN TRANSFORMATIONS.

ENV.SN	IN REGULAR TEXT, DO SEVERAL STRAIGHT FORWARD
ENV.FN	TRANSLATIONS BY MATCHING BLISS-10 PHRASES AND
	REPLACING THEM WITH BLISS-36C EQUIVALENTS. IF
	A SIMPLE SUBSTITUTION IS NOT POSSIBLE THEN A
	WARNING IS GENERATED. ALL TRANSLATIONS OF ONE
	TYPE ARE MADE ON A LINE, THEN THE NEXT TYPE OF
	TRANSLATION IS DONE TO THE LINE UNTIL ALL TYPES
	OF TRANSLATION ARE COMPLETE.  THE TYPES ARE:

FIXPER	FIRST REPLACE '@' WITH '.' AND '_' WITH '='.
	CHANGE '$' TO '%' AT THE END OF MACROS, IF A MACRO
	IS NESTED IT WILL GENERATE %QUOTE WHEN NEEDED.

DELPNT	WHEN VAR<0,36> OR VAR<0,0> APPEAR REPLACE WITH VAR.

NEWKWD	TRY TO MATCH THE TEXT AGAINST A LIST OF KNOWN KEYWORDS.
	FOR EACH KEYWORD FOUND, INDEX INTO THE 'NEW.KW' TABLE
	IN ORDER TO FIND THE KEYWORD TO REPLACE THE ONE FOUND.
	(RADIX50 -> %RAD50_10).  SOME KEYWORDS DO NOT TRANSLATE,
	FOR EXAMPLE: (COPYII -> %(**WARNING**BLISS10**)% COPYII).

OCTKWD	CHANGES OCTAL CONSTANTS: ( #273 -> %O'273')

POINTY	TRIES TO AVOID THE PROBLEM OF HAVING STRUCTURE
	REFERENCES FOLLOWED BY <P,S> EXPAND INTO ILLEGAL
	BLISS-36C SYNTAX: NAME[..]<..> COULD EXPAND TO
	NAME[..]<..><..>.  TO PROTECT AGAINST THIS HAVE
	NAME[..]<..> TRANSLATE TO (NAME[..])<..>.

WHEN THESE TRANSLATIONS ARE DONE, ANY TRANSFORMATION THAT WAS
IN PROGRESS WILL BE CONTINUED (IE. 'TRANS.TYPE' IS NOT NULL).
IF THERE IS NO TYPE OF TRANSFORMATION CURRENTLY PENDING THEN
THE STRING IS MATCHED AGAINST 'ALL.TRNS' TO SEE WHICH TYPE OF
TRANSFORMATION SHOULD BE TRIED.  'ALL.TRNS' WILL MATCH IF ANY
TRANSFORMATION KNOWN TO CVT10 CAN BE FOUND.  'TRANS.TYPE' IS
SET TO THE TITLE OF THE TRANSFORM, AND THE TRANSFORM IS TRIED.
THESE TRANFORMATIONS ARE DESCRIBED LATER IN THIS DOCUMENT.
BELOW ARE THE NON-REGULAR TEXT TRANSLATIONS.  THE INPUT LINE
IS READ UP TO A CHARACTER THAT SIGNALS NON-REGULAR TEXT (LIKE
A QUOTE OR EXCLAMATION POINT). THE TEXT PRIOR TO THE BREAKING
CHARACTER IS PROCESSED AS REGULAR TEXT, AND THE TEXT WHICH IS
AFTER THE BREAK CHAR IS SCANNED TO FIND THE END OF THE SPECIAL
TEXT.  THE SPECIAL TEXT IS TRANSLATED BY RULES THAT DEPEND ON
THE BREAK CHAR.  THERE IS ONE TRANSLATION ROUTINE FOR EACH OF
THE BREAK CHARACTERS.  AFTER THE SPECIAL TEXT IS TRANSLATED,
THE NORMAL STATE IS RESUMED AND THE TEXT FOLLOWING THE END OF
THE SPECIAL TEXT IS PROCESSED.  THE STATES ARE: NORMAL('N'),
COMMENT('C'), PERCENT COMMENT('P'), LITERAL NAME('L'), AND
QUOTED STRING('Q1' AND 'Q2').

<BREAK CHAR>			<ACTION TAKEN>

    !		ALL TEXT UNTIL A NEWLINE IS PASSED ON WITHOUT
	ANY CHANGES.  AFTER THE NEWLINE THE 'NORMAL' STATE IS
	RESUMED (NEW BREAK CHARS ARE LOOKED FOR).  STATE: 'C'.

    %		THE % IS REPLACED WITH %( AND ALL TEXT IS PASSED
	ON WITHOUT CHANGE UNTIL ANOTHER % IS ENCOUNTERED. THE
	CLOSING PERCENT CHANGES TO )% AND THE NORMAL STATE IS
	ONCE AGAIN ENTERED.  THESE PERCENT COMMENTS MAY EXTEND
	OVER SEVERAL INPUT LINES.  STATE: 'P'.

    ?		A LITERAL NAME FOLLOWS SO A SPECIAL PATTERN IS
	USED TO MATCH THE IDENTIFIER.  DOLLARSIGN, PERCENTSIGN,
	AND DOT ARE ALLOWED TO OCCUR IN A NAME: ?J..DAT$3. THIS 
	SPECIAL PATTERN (CALLED 'SP.IDENT') IS USED TO FIND THE
	EXTENDED IDENTIFIER'S NAME SO THAT IT CAN BE TRANSLATED
	INTO:  %NAME('J..DAT$3').  STATE: 'L'.

  ' OR "	QUOTED STRINGS HAVE SEVERAL TRANSLATIONS THAT CAN
	BE MADE.  DOUBLE QUOTED STRINGS MAY BE ONE CHARACTER LONG
	OR A WARNING RESULTS.  NORMALLY, "Z" -> %C'Z', "?M"->13.
	QUESTION MARK INSIDE OF A QUOTED STRING SIGNALS A CONTROL
	CHARACTER SO '?M' -> %CHAR(13).  IN GENERAL, THE STRING
	'ABC?M?JDE' ---> %STRING('ABC',%CHAR(13),%CHAR(10),'DE').
	STATE: 'Q1' FOR SINGLE QUOTES, 'Q2' FOR DOUBLE QUOTES.


			PSEUDO-OPS

!CVTCOM		MAKE ALL INPUT LINES THAT FOLLOW !CVTCOM INTO
	COMMENTS.  USED TO SAVE THE ORIGINAL BLISS-10 CODE AS A
	COMMENT WHEN DIFFERENT CODE HAS TO BE ADDED.

!MOCTVC		TURN OFF CVTCOM, PROCESS NORMALLY AGAIN.

!CVTTEXT	TREAT ALL INPUT AS IF IT WAS BLISS-36C CODE THAT
	HAD BEEN COMMENTED OUT.  REMOVE THE COMMENT CHAR (!) AND
	OUTPUT THE LINE WITHOUT ANY CHANGES.

!TXETTVC	TURN OFF CVTTEXT, PROCESS NORMALLY AGAIN.
     THE TABLE OF TRANSFORMS ('TRNTAB') MAPS BLISS-10 RESERVE
WORDS INTO THE TITLE OF A TRANSFORMATON.  THIS MAPPING IS MANY
TO ONE: 'LOCAL' AND 'STACKLOCAL' BOTH MAP TO 'NDEC'. INSIDE OF
THE 'NDEC' TRANSFORM THEY ARE TREATED THE SAME.  'NDEC' AND ALL
THE OTHER TRANSFORMS ARE DESCRIBED BELOW.  THE TITLES ARE USED
TO CALL THE RIGHT ROUTINE FOR THE GIVEN RESERVE WORD.
     THE 'TRANS.TYPE' IS SET TO THE TITLE OF THE TRANSFORM IS
PROGRESS, WHEN THE TRANSFORM IS COMPLETE 'TRANS.TYPE' IS SET TO
NULL.  THIS ALLOWS THE TEXT NEEDED FOR THE TRANSFORM TO BE ON
SEVERAL INPUT LINES.  BUT A FEW TRANSFORMS ARE ONLY SMART ENOUGH
TO WORK WHEN THE INFORMATION IS ON ONE LINE.  IF A TRANSFORM IS IN
PROGRESS AND IT IS DISCOVERED THAT CVT10 IS UNABLE TO CONTINUE THAT
TRANSFORM (CAN'T FIND SOME PHRASE IT NEEDS) THEN A 'PUNT' IS DONE.
WHEN CVT10 PUNTS IT SETS 'TRANS.TYPE' TO NULL, RESETS THE STATE TO
'N', AND OUTPUTS THE INPUT LINE WITH THE CHANGES UP TO THE PUNT.


	<PROGRAM FLOW>

		    GET INPUT AND		<---------------+
		DETERMINE THE STATE				!
		       /   \				       /!\
		      /     \  (STATE NOT 'N')			!
		     /	     \					!
	(STATE 'N') /	     !\---> 'P' PERCENT COMMENT ------->!
		   /	     ! \		    !		!
		  /	     !	\	(ENDING %)  +---->SET STATE
		  !	     !	 \		      	    TO 'N'
	    FIXPER/DELPNT    !	  \				!
		  !	     !	   \---> 'L' LITERAL NAME ----->!
		NEWKWD	     !\					!
		  !	     ! \----> 'C' COMMENT ------------->!
		OCTKWD	     !					!
		  !	     !					!
		POINTY	      \---> 'Q1' & 'Q2' QUOTED STRING ->!
		  !						!
		  !\						!
		  ! \ (NO CURRENT TRANSFORM,			!
   (TRANSFORM	  !  \ 'TRANS.TYPE' IS NULL)			!
   IN PROGRESS)	  !   \					       /!\
		  !    \					!
		  !	MATCH STRING AGAINST 'ALL.TRNS'		!
		  !	TO TRY TO FIND A TRANSFORM TO DO.	!
		  !		!				!
		 \!/		!\				!
		  !		! \	(NO TRANSFORM FOUND)	!
		  !		!  \--------------------------->!
		  !		!	  			!
		  !		! (FOUND NEW TRANSFORM)		!
		  \------+------/				!
	/!\		 !				       /!\
	 !		 !					!
   GET MORE INPUT	 !					!
	 !		 !					!
	 !	 CALL THE APPROPRIATE				!
	 !	TRANSFORMATION ROUTINE				!
	 !		 !					!
	 !<--------------!------------------------------------->!
	    (SUCCESS)			(HAD TO PUNT)
	ACTIONS TAKEN FOR EACH TITLE: TRANSFORMATION ROUTINES





TITLE:		NDEC	(NORMAL DECLARATIONS)

DESCRIPTION:	THE DECLARATION IS MATCHED TO FIND THE ATTRIBUTES
	AND THE STRUCTURE INFO.  THIS IS PUT INTO BLISS-16C SYNTAX.

META-EXAMPLE:	<SIZE> <DECNAME> <STRUCTURE> <VARIABLE> <DIM> = <INIT>;
	->	<DECNAME>
		    <VARIABLE> : <STRUCTURE> <DIM,SIZE> INITIAL <INIT>;

CLASSES:	<DECNAME> MAY BE: GLOBAL, LOCAL, MAP, REGISTER, OWN,
		STACKLOCAL, EXTERNAL (NOTE: LINKAGE <=> STRUCTURE)

EXAMPLE:
	OWN STVEC X:Y[2];		OWN
					    X:	STVEC[2],
					    Y:	STVEC[2];

	LOCAL Z[3];		LOCAL
					    Z:	VECTOR[3];

	EXTERNAL FORLINK FLOROOT, BLSLINK OSSIM;
			--->	EXTERNAL
				    FLOROOT:	FORLINK,
				    OSSIM:	BLSLINK;

LIMITS:		SEVERAL VARIABLES MAY BE DECLARED UNDER A <DECNAME>
	AND THIS MAY BE ON MULTIPLE LINES.  HOWEVER, EACH VARIABLE
	MUST HAVE ITS WHOLE DECLARATION ON ONE LINE.  IF THIS IS
	NOT THE CASE THE REST IS PUNTED.


NOTES:	BLISS-10 DOES NOT HAVE LINKAGE ATTRIBUTES, SO THE
	FORWARD ROUTINE, NORMAL DECS, AND GLOBAL ROUITNES DO NOT
	LOOK FOR LINKAGE PHRASES.  THE TRANSFORMATIONS ARE DOCUMENTED
	TO DO THINGS, HOWEVER THEY DO SOMETHING ONLY IN THE CVT11
	VERSION.  IN CVT10 THEY IGNORE THE ATTRIBUTES.

TITLE:		RDEC	(REQUIRE FILE DECLARATIONS)

DESCRIPTION:	THE FILE SPECS ARE PUT INTO QUOTES UNLESS THEY
	ARE ALREADY QUOTED (THEN THEY ARE LEFT ALONE).

META-EXAMPLE:	REQUIRE <FILE SPECS>;  ->  REQUIRE '<FILE SPECS>';

CLASSES:	ONLY REQUIRE IS MATCHED FOR THIS TRANSFORMATION.

EXAMPLE:	REQUIRE FOO.REQ;   ->	REQUIRE 'FOO.REQ';
		REQUIRE 'BAR.REQ'; ->	REQUIRE 'BAR.REQ';

LIMITS:		THE FILE SPECS MUST BE ON THE SAME LINE AS
	THE 'REQUIRE' RESERVE WORD.  IF QUOTES OCCUR AS A
	PART OF THE FILE SPECS THE RESULT WILL BE AS NOTED
	ABOVE, HOWEVER, THE SYNTAX OF THE FILE SPECS MAY BE
	IN ERROR: REQUIRE JOE'S.DOC -> REQUIRE 'JOE'S.DOC'.

			-----

TITLE:		FDEC	(FORWARD DECLARATIONS)

DESCRIPTION:	ONLY ROUTINES MAY BE DECLARED FORWARD IN BLISS-10
	SO THE FORWARD DECLARATION IS CHANGED TO FORWARD ROUTINE.
	AFTER BEING CHANGED TO FORWARD ROUTINE, THE DECLARATION
	IS TREATED AS AN 'NDEC' SO THAT LINKAGES CAN BE MOVED.

META-EXAMPLE:	FORWARD <LINKAGE> <ROUTINE NAME>;
	->	FORWARD ROUTINE
		    <ROUTINE NAME>:	<LINKAGE>;

EXAMPLE:	FORWARD BLSLNK HCSIO,
			DBFLO1;
			    ->	FORWARD ROUTINE
				    HCSIO:	BLSLNK,
				    DBFLO1;

LIMITS:		THE SAME LIMITS EXIST FOR FDEC AS NDEC.

			-----

TITLE:		SDEC	(SWITCHES DECLARATIONS)

DESCRIPTION:	SWITCHES DECLARATIONS ARE REMOVED FROM THE
	PROGRAM.  THE NEWLINE AFTER THE DECLARATION IS ALSO
	REMOVED UNLESS IT CONTAINED A FORMFEED (WHICH IS KEPT
	IN ORDER TO MAINTAIN THE PROGRAM'S FORMAT).

META-EXAMPLE:	SWITCHES <SWITCH LIST>; -> <NULL>

EXAMPLE:	SWITCHES NOLIST,NOFINAL;  -> <NULL>

LIMITS:		THE SWITCH LIST MUST BE ON THE SAME LINE AS THE
	SWITCHES RESERVED WORD.  IF A ANYTHING WAS ON THE LINE
	AFTER THE DECLARATION, IT WILL BE KILLED AS WELL.  THIS
	WILL NORMALLY KILL COMMENTS ABOUT THE SWITCHES, HOWEVER
	BADLY WRITTEN CODE MAY HAVE NON-COMMENT TEXT AFTER THE
	SWITCHES DECLARATION.  THE TEXT WOULD BE REMOVED IN THIS
	CASE, BUT THIS HAS NEVER BEEN OBSERVED IN A REAL PROGRAM.
TITLE:		MDEC	(MACHOP DECLARATIONS) <<BLISS-36C ONLY>>

DESCRIPTION:	MACHOP DECLARATIONS ARE TRANFORMED INTO MACROS.
	A 'BUILTIN MACHOP;' DECLARATION IS GENERATED FIRST, THEN
	A MACRO IS WRITTEN THAT EXPRESSES THE MACHOP.

META-EXAMPLE:	MACHOP <OP NAME> = <OP NUM>;
	->	BUILTIN MACHOP;
		MACRO
		    <OP NAME>[] = MACHOP(<OP NUM>, %REMAINING);

EXAMPLE:	MACHOP HLT = 3722,
			SMV = 2117;
		-->		BUILTIN MACHOP;
				MACRO
				    HLT[]=MACHOP(3722,%REMAINING),
				    SMV[]=MACHOP(2117,%REMAINING);

			-----

TITLE:		BDEC	(BIND DECLARATIONS)

DESCRIPTION:	THE ATTRIBUTES OF A BIND DECLARATION ARE MOVED TO
	THE RIGHT PLACE FOR BLISS-16C SYNTAX.  IF THE OBJECT THAT
	IS BEING BOUND IS EITHER PLIT OR UPLIT A DEFAULT 'VECTOR'
	ATTRIBUTE IS PUT ON.  OTHERWISE THERE IS NO DEFAULT.

META-EXAMPLE:	BIND <STRUC> <VAR> = <OBJECT>;
			   ->	BIND <VAR> = <OBJECT>:	<STRUC>;

CLASSES:	BIND AND GLOBAL BIND TO PLITS, UPLITS, AND <OTHER>.

EXAMPLE:	BIND DVSTRC Z = FRMNAM,
		    MNEMS = PLIT(
				3, 7,
				4, 2);
	->	BIND
		    Z = FRMNAM: DVSTRC,
		    MNEMS = PLIT(
				3, 7,
				4, 2):	VECTOR;

LIMITS:		BINDS TO OTHER THAN PLITS (OR UPLITS) MUST HAVE THE
	THE <STRUC>, <VAR>, AND <OBJECT> ON ONE LINE.  BINDS TO PLITS
	AND UPLITS MAY EXTEND OVER MANY LINES, BUT THEY MUST BE THE
	LAST BIND IN THE LIST (SEE THE EXAMPLE ABOVE).  THIS MEANS
	YOU CAN HAVE ONLY ONE PLIT BINDING PER BIND DECLARATION,
	IF THERE ARE MORE THAN ONE, ONLY THE LAST ONE WILL HAVE
	THE 'VECTOR' STRUCTURE ATTRIBUTE PUT ON.  THIS IS BECAUSE
	CVT10 USES A HEURISTIC THAT SAYS A SEMICOLON ENDS A PLIT,
	IF YOU HAVE A LIST OF PLITS: P1, P2, P3; ONLY THE LAST ONE
	IS CAUGHT BY THE HEURISTIC.  SOMEDAY CODE COULD BE PUT IN
	TO HAVE BIND DECLARATIONS COUNT UNTIL BALANCED PARENTHESES
	RATHER THAN LOOKING FOR SEMICOLONS.  THIS WOULD EXPAND THE
	ABILITY OF BDEC.  HOWEVER, MOST PLITS SEEM TO BE LAST OR
	ALONE(CODING STANDARDS), SO MOST ARE TRANSFORMED CORRECTLY.
TITLE:		MOD	(MODULE HEADERS)

DESCRIPTION:	FIX-UP THE MODULE HEADER BY REMOVING A SIX12 SWITCH
	IF IT APPEARS, AND BY INSERTING SOME CONDITIONAL SWITCHES
	THAT SPECIFY THE LANGUAGE (TO AID IN TRANSPORTABILITY THERE
	IS A SWITCH FOR BLISS-32, BLISS-36, AND BLISS-36).

META-EXAMPLE:	MODULE <MODULE NAME>(<SIX12 SW> <OTHER SWITCHES>) =
	-->	MODULE <MODULE NAME>(%BLISS36(BLISS10_REGS %QUOTE,)
			LANGUAGE(%BLISS36(BLISS36)
				%BLISS32(BLISS32)
				%BLISS16(BLISS16)), <OTHER SWITCHES>) =

EXAMPLE:	MODULE DBCELL(TIMER = EXTERNAL(SIX12),NOLIST,MAIN) =
	-->	MODULE DBCELL(%BLISS36(BLISS10_REGS %QUOTE,)
			LANGUAGE(%BLISS36(BLISS36)
				%BLISS32(BLISS32)
				%BLISS16(BLISS16)), NOLIST,MAIN) =

LIMITS:		THE MODULE HEADER DECLARATION MUST APPEAR ON ONE LINE
	IN ORDER TO BE TRANSFORMED.  CVT10 LOOKS FOR THE EQUAL SIGN
	AFTER THE SWITCHES LIST.  SIX12 IS REMOVED FROM THE HEADER AND
	THE REST OF THE SWITCHES ARE LEFT, BUT SOME OF THOSE SWITCHES
	MAY NOT BE VALID.  THESE MUST BE DEALT WITH BY HAND.
		WHEN CVT10 WAS WRITTEN FOR TRANSLATING, THERE WAS A
	PARTICULAR APPLICATION IN MIND, SO THIS MODULE HEADER FORMAT
	CORRESPONDS TO THE NEEDS OF THAT APPLICATION.  HOWEVER, OTHER
	APPLICATIONS MIGHT WANT TO CHANGE THE TEXT IN 'MH.INFO' TO
	SOME MORE APPROPRIATE SET OF SWITCHES.
			-----

TITLE:		GTR	(GLOBAL ROUTINE)

DESCRIPTION:	MOVE THE LINKAGE TYPE FOR CORRECT BLISS-16C SYNTAX.

META-EXAMPLE:	GLOBAL ROUTINE <LINKAGE> <NAME> = <BODY>
	-->	GLOBAL ROUTINE <NAME> :	<LINKAGE> = <BODY>

EXAMPLE:	GLOBAL ROUTINE FORLNK IOSTUFF = BEGIN
	-->		GLOBAL ROUTINE IOSTUFF :  FORLNK = BEGIN

LIMITS:		THE EQUAL SIGN MUST BE ON THE SAME LINE AS THE
	GLOBAL ROUTINE RESERVE WORDS.  THERE MAY BE ANYTHING
	FOLLOWING THE EQUAL SIGN, IT WILL BE LEFT AS IT IS.
TITLE:		SEL	(SELECT STATEMENTS)

DESCRIPTION:	SQUARE BRACKETS ARE PUT AROUND SELECT LABELS.
	THE NSET AND TESN RESERVED WORDS -> SET AND TES.

META-EXAMPLE:	SELECT <SELEXP> OF
		    NSET
		    <LEXP1> : <AEXP1>
		    <LEXP2> : <AEXP2> ...
		    TESN
			->	SELECT <SELEXP> OF
				    SET
				    [<LEXP1] : <AEXP1>
				    [<LEXP2>] : <AEXP2> ...
				    TES

EXAMPLE:    SELECT .X OF	-->	    SELECT .X OF
		NSET				SET
		3: FOO(.K+1);			[3]:  FOO(.K+1);
		#26 : .K;			[%O'26']: .K;
		.V : .Z*.K			[.V]:  .Z*.K
		TESN				TES

LIMITS:		THE SELECT TRANSFORM DOES NOT PARSE THE SELECT
	STATEMENT, IT SIMPLY MAKES NOTE OF WHAT IS GOING BY ON
	A LINE BY LINE BASIS: 'SELECT' SIGNALS THAT 'SEL.DEPTH'
	(SEE DETAILS LATER) BE INCREMENTED BECAUSE A SELECT
	STATEMENT HAS BEEN ENTERED.  'NSET' SIGNAL THAT EXPRESSIONS
	ARE COMING (NSET->SET).  A COLON SIGNALS THAT THE STUFF
	TO ITS LEFT IS A SELECT LABEL AND SHOULD BE PUT INTO
	SQUARE BRACKETS.  THIS IS NOT ALWAYS THE RIGHT THING TO
	DO WHEN A COLON IS SEEN, SO THE CASE TRANSFORM COMMUNICATES
	TO THE SELECT TRANSFORM ABOUT WHERE IT JUST PUT IN COLONS
	FOR CASE LABELS, 'INHIBIT.SELLBL' (IF 'TRUE') INFORMS THE
	SELECT TRANSFORM THAT THE COLON IS NEW (WHEN THERE IS A
	CASE INSIDE OF A SELECT).
	SELECTS MAY BE OVER SEVERAL LINES AND NESTED, THEY MAY BE
	FORMATED FREELY EXCEPT(!!!) NO SITUATION MUST OCCUR THAT
	WOULD WANT TO HAVE MORE THAN ONE LABEL PER LINE.  ALSO,
	SINCE QUOTED STRINGS ARE HANDLED ELSEWHERE, A SELECT LABEL
	CAN'T BE PUT ON AROUND ONE.  'M' : X=.X+1; -> 'M'[] : X=.X+1;
	IE: THE BRACKETS ARE PUT AS SOON AS POSSIBLE; THIS IS NOT
	ALL THAT COMMON AND CAN BE EASILY HAND EDITED.  IT IS NOT
	POSSIBLE TO FUDGE CVT10 INTO DOING THAT CASE CORRECTLY.
	'TESN' DECREMENTS 'SEL.DEPTH'.  TESN -> TES.
TITLE:		CASE	(CASE STATEMENTS)

DESCRIPTION:	THE CASE TRANSFORM COUNTS UP THE NUMBER OF CASES
	IN A CASE STATEMENT AND GENERATES A BLISS-36C PHRASE AT
	THE TOP OF THE STATEMENT: FROM 0 TO <N>.  ALSO, EACH OF
	THE CASES IS LABEL WITH ITS NUMBER.

META-EXAMPLE:	CASE <CASEXP> OF
		    SET		    CASE <CASEXP> FROM 0 TO <N> OF
		    <EXP0>;	-->	SET
		    <EXP1>;		[0]:	<EXP0>;
		    <EXP2>;		[1]:	<EXP1>;
		    ...			[2]:	<EXP2>
		    <EXP<N>>		...
		    TES			[<N>]:	<EXP<N>>

EXAMPLE:    CASE .X + 1 OF
		SET		-->    CASE .X + 1 FROM 0 TO 3 OF
		Y = .Y + 1;		SET
		(LOCAL Z;		[0]:	Y = .Y +1;
		Z = Y);			[1]:	(LOCAL Z;
		.Y;				Z = .Y);
		BAR(Y+1)		[2]:	.Y;
		TES			[3]:	BAR(Y+1)
					TES

LIMITS:		THE CASE TRANSFORM IS BY FAR THE MOST COMPLEX OF
	THE CVT10 TRANSFORMS.  HOWEVER, NO SITUATION SHOULD OCCUR
	THAT WOULD CAUSE THE CASE TRANSFORM TO GENERATE MORE THAN
	ONE LABEL PER LINE.  CASES MAY BE NESTED INSIDE OF CASES
	AND SELECTS AND MAY BE AS LONG AS THEY WANT.  THE LINES
	IN A CASE STATEMENT MUST BE QUEUED THAT THE NUMBER OF
	CASES CAN BE PUT ON THE TOP WHEN DONE.  THIS MEANS THAT
	A PUNT FOR SOME REASON WILL STRAND A BUNCH OF LINES ON
	THE QUEUE.  IF THIS HAPPENS, AN ERROR MESSAGE WILL BE
	PRINTED AND THE LINES UNQUEUED (SEE ABOUT QUEUES LATER).
	CASE AND SELECT TRANSFORMS INTERACT SOME WHEN THEY ARE
	NESTED.  THIS INTERACTION IS TO AVOID MISUNDERSTANDINGS
	ABOUT THE LABELS GENERATED.  IF A SELECT INSIDE OF A CASE
	WANTS A LABEL GENERATED, BUT THE CASE TRANSFORM WANTS TO
	PUT OUT ITS OWN LABEL TROUBLE RESULTS.  THIS IS VERY RARE
	AND REALLY JUST AN EXAMPLE OF THE 'ONE LABEL PER LINE' RULE.
	DETAILED DESCRIPTION OF KEY VARIABLES AND FLOW

		DATA STRUCTURES AND FORMAT

TCC	- MATCHES ALL OF THE CARRAGE RETURN, LINE FEEDS, AND FORM
	FEEDS AT THE END OF THE INPUT LINE.  THESE ARE SAVED AND
	THEN PUT OUT APPENDED TO THE TRANSLATED LINE.  DOING THIS
	PRESERVES THE ORIGINAL VERTICAL FORMAT.

QUEUE	- FUNCTION THAT MAINTAINS A FIFO DATA-STRUCTURE, IT IS
	USED TO STORE UP THE LINES OF A CASE STATEMENT SO THAT
	THE PHRASE 'FROM 0 TO <HIGHBOUND>' CAN BE FILLED IN WITH
	THE NUMBER OF CASE ALTERNATIVES.  A LINE IS QUEUED DURING
	THE CASE TRANSFORM, WHEN THE TES IS FOUND THE LINES ARE
	UNQUEUED AND THE APPROPRIATE HIGH-BOUND IS PUT ON.

PUSH	- IMPLEMENTS A STACK DATA-ABSTRACTION, IT IS USED TO
	STACK STATE INFORMATION ABOUT CASES AND SELECTS WHEN
	A CASE IS FOUND INSIDE A CASE.  THE NUMBER OF CASE
	ALTERNATIVES SO FAR, THE NUMBER OF PARENS SEEN IN
	THIS CASE ETC. ARE PUSHED ONTO THERE OWN STACKS BY
	CALLING PUSH(STACKNAME,ITEM_TO_BE_PUSHED).

CELL	- A CELL IS THE BASIC DATA ITEM FOR STACKS AND FOR
	QUEUES.  THE DATA ITEM IS PUT INTO A FIRST PART OF
	A CELL AND A LINKING POINTER IS PUT INTO THE SECOND
	PART OF THE CELL.  THIS LIST STRUCTURE IS MAINTAINED
	BY THE QUEUE AND STACK ROUTINES.  NOT SURPRISINGLY
	(CONSIDERING MY BACKGROUND), THE ELEMENTS OF THE CELL
	ARE GIVEN THE LISP NAMES: 'CAR' AND 'CDR'.


		STANDARD PATTERN DEFINITIONS

SPANBLK	- NON-NULL MAXIMUM SEQUENCE OF SPACES AND TABS
SPANBLKN- SAME AS SPANBLK EXCEPT IT ALSO MATCHES THE NULL STRING

NAME	- BLISS-10 IDENTIFIER NAME, STARTS WITH A LETTER AND IT
	 CONTAINS LETTERS AND DIGITS.

SP.IDENT- SPECIAL IDENTIFIER THAT STARTS '.' OR '%' OR '$'

KEYWORD	- VALID BLISS-10 KEYWORDS THAT TRANSLATE TO BLISS-36C
	AND THOSE WHICH GENERATE %WARNINGS

LTERM	- SET OF DELIMITERS THAT ARE VALID TO THE LEFT OF A NAME
RTERM	- SAME AS LTERM EXCEPT FOR THE RIGHT HAND SIDE

OCTSCAN	- PATTERN THAT FINDS OCTAL CONSTANTS: #522 -> %O'522'
		TRANSFORMATION PATTERNS

DECNAME	- SUBSET OF DECLARATIONS WITH SIMILAR FORM(DATA DECS)
DECLARATION - PATTERN THAT MATCHES WHEN A 'DECNAME' IS FOUND

PARSE	- SEVERAL PATTERNS THAT 'PARSE-UP' A 'DECNAME' DECLARATION

ALL.TRNS - ALL DECLARATIONS CVT10 KNOWS ABOUT, THEY FALL INTO
	CATAGORIES (SEE TRNTAB) EACH CATAGORY HAS A PARSER FOR IT.

TRNTAB	- WHEN ONE OF 'ALL.TRNS' IS FOUND IT IS LOOKED UP IN THE
	TRANSLATION TABLE TO SEE WHAT CATAGORY IT FALLS INTO.
	THE APPROPRIATE ACTION IS TAKEN BASED ON THE CATAGORY.
	BESIDES 'ALL.TRNS', CASES, SELECTS, AND OTHER TRANSFORMS
	ARE IN TRNTAB, EACH WITH A CATAGORY AND ASSOCIATED ACTION.
	TRNTAB: BIND, CASE, EXTERNAL, FORWARD, GLOBAL, GLOBAL BIND,
	GLOBAL ROUTINE, LOCAL, MACHOP, MAP, MODULE, OWN, REGISTER
	REQUIRE, SELECT, STACKLOCAL, SWITCHES.


		VARIABLES OF INTEREST

CASE.DEPTH - LEVEL OF NESTING OF CASE STATEMENTS.  WHEN CASE.DEPTH
	EQUALS ZERO YOU ARE NOT INSIDE OF A CASE STATEMENT, WHEN
	THE DEPTH IS NON-ZERO CHECKS ARE MADE TO SEE IF ADDITIONAL
	INDENTATION NEEDS TO BE DONE AND IF A CASE LABEL SHOULD BE
	GENERATED.  SERVERAL SECTIONS OF CODE ARE PRECEEDED BY A
	STATEMENT OF THE FORM: 'EQ(CASE.DEPTH,0) :S(SKIP.SECTION)'

MACRO.DEPTH -	LEVEL OF NESTING OF MACROS, FOR %QUOTES.

TRANS.TYPE - THE TRANS.TYPE IS THE TYPE OF TRANSFORMATION THAT
	IS CURRENTLY IN PROGRESS.  WHEN TRANS.TYPE IS NON-NULL
	A JUMP IS MADE TO THE CORRECT PROCESSOR, WHEN TRANS.TYPE
	IS NULL PATTERN MATCHING OCCURES TO TRY TO DETERMINE WHAT
	TYPE OF TRANSFORMATION SHOULD BE DONE.  THE TRANS.TYPES
	CORRESPOND TO THE TRNTAB, THE TRANS.TYPE IS SET FROM
	LOOK-UPS IN THE TRNTAB.  WHEN A TRANSFORMATION IS DONE
	(OR PUNTS) IT SETS TRANS.TYPE TO NULL.

STRING	- THE TEXT CURRENTLY BEING CONSIDERED FOR TRANSFORMATION,
LINE	- THE REMAINING TEXT (TO THE RIGHT OF THE BRKCH).
BRKCH	- THE CHARACTER THAT SIGNALS A CHANGE IN THE ENVIRONMENT.
	THE ACTUAL BREAKING CHARACTER IS TRANSLATED TO A NEW
	BREAKING CHARACTER BY A LOOK INTO THE BRKTAB, FOR EXAMPLE,
	BRKTAB<'%'> = '%(', BRKTAB<'"'> = "'".
(NOTE)	AFTER THE 'STRING' IS TRANSFORMED IT IS SENT TO THE OUTPUT
	SECTION, THE 'OUTSTR' (OUTPUT STRING) IS CONCATENATED WITH
	THE 'STRING' AND 'BRKCH' THEN 'LINE' IS MATCHED FOR ANOTHER
	BRK CHAR AND A NEW 'STRING' AND 'BRKCH' AND 'LINE' APPEAR.
	WHEN 'LINE' BECOMES NULL A NEW INPUT LINE IS FETCHED FROM
	THE INPUT FILE, AND THE 'OUTSTR' IS OUTPUT OR QUEUED.

	'LINE' = FILE INPUT, 'OUTSTR' = NULL <--- ('LINE' IS NULL) <-+
								     !
	'LINE' -> 'STRING' 'BRKCH' 'LINE'    <--- (MORE 'LINE') -----!
	'BRKCH' -> 'BRKTAB<BRKCH>'				     !
	'STRING' -> TRANSFORMS('STRING')		       	     !
 	'OUTSTR' -> 'OUTSTR' 'BRKCH' 'STRING' ---------------------> !
		ENVIRONMENTS

    SO THAT TRANSFORMS ARE DONE ONLY WHERE APPROPRIATE, RATHER
    THAN IN QUOTED STRINGS OR IN COMMENTS, THE TOP LEVEL
    STRUCTURE OF CVT10 IS A FINITE STATE MACHINE.  THE STATES
    ARE: NORMAL(N), IN A COMMENT(C), IN A PERCENT COMMENT(P),
    IN A QUOTED STRING(Q1 & Q2), AND IN A LITERAL(L).
    EACH STATE HAS ASSOCIATED WITH IT A RULE FOR LEAVING
    THE STATE AND ENTERING ANOTHER, FOR EXAMPLE: THE NORMAL
    STATE EXITS TO THE COMMENT STATE WHEN A '!' IS ENCOUNTERED.
    N,C,P,Q1,Q2,L ARE REALLY PATTERNS DESCRIBING WHEN TO LEAVE
    THEIR STATE (SO PATTERN N WILL BREAK ON '!').

	BASIC FLOW PROCEDURE:	<ASSUME IN STATE S AT THIS POINT>

1.	MATCH PATTERN S AGAINST INPUT LINE;

2.	IF <MATCH SUCCEEDS(IMPLIES TIME TO LEAVE STATE S)>
	    THEN BEGIN
1S.		PROCESS THE LINE UP TO THE CHARACTER THAT SAYS TO
		LEAVE BY THE RULES FOR PROCESSING TEXT IN STATE S;
2S.		LET 'STATE = STATAB<BRKCH>', IE. CALCULATE THE NEW
		STATE BY LOOKING IT UP IN A TABLE REFERENCED BY
		THE BREAKING CHARACTER. (EX: STATAB<'!'> = 'C').
		END
	    ELSE			! FAILED, DO NOT LEAVE STATE S
		IF <HAD TO MATCH ON THIS LINE>
		    THEN BEGIN
1F.			REPORT ERROR THAT THE STATE WASN'T EXITED ON
			ON THIS LINE(A QUOTED STRING OVER THE LINE
			BOUNDRIES IS LEGAL IN BLISS-11 BUT ILLEGAL
			IN BLISS-16C AND WILL CAUSE A WARNING TO BE
			GENERATED AS A COMMENT ON THE PROGRAM);
2F.			SET THE STATE TO 'N';
			END
		    ELSE BEGIN
3F.			PROCESS THE TEXT ACCORDING TO THE STATE;
			REMAIN IN THE SAME STATE (LIKE % COMMENTS
			WHICH CAN SPAN MANY LINES).
			END

3.	GET MORE TEXT TO TRANSLATE AND REPEAT THE PROCESS.
	(NOTE: MORE INPUT DOESN'T ALWAYS IMPLY ANOTHER INPUT
	LINE. WHEN A BREAK CHAR IS FOUND IN A LINE THE TEXT TO
	THE LEFT OF THE BREAK CHAR IS PROCESSED BY THE CURRENT
	STATE, AND THE NEW STATE RECIEVES THE PORTION AFTER
	THE BREAK CHARACTER TO THE END OF THE LINE).
		MODIFICATIONS TO CVT10

	IF A CATOTROSPHIC INTERNAL ERROR OCCURS A VARIABLE
	LIST WILL BE DUMPED, THIS IS PROBABLY NOT OF ANY
	USE TO THE AVERAGE USER.  IF CVT10.SNO IS TO BE
	MODIFIED, THEN SNOBOL HAS TO BE RUN AGAIN IN ORDER
	TO MAKE A VERSION.  BELOW ARE THE CHANTS NEEDED:
				.R SYS:SNOBOL
				*^C
				.SAVE SNOBOL.HGH
				SNOBOL SAVED

				.RU
				*,=CVT10.SNO
				EXIT

				.SAVE CVT10
				CVT10 SAVED

				.RU  (OR LATER, RU CVT10)



		DEBUGGING AIDS

	IF CVT10 IS NOT WORKING CORRECTLY IT IS USUALLY USEFUL TO
USE THE BUILTIN DEBUGGING AIDS.  IN ORDER TO MAKE AVAILABLE THESE
AIDS CVT10 HAS TO BE SLIGHTLY MODIFIED.  AT THE BEGINNING OF THE
DEBUGGING SECTION THERE IS A JUMP TO THE 'EXIT TO SAVE CORE IMAGE'
SECTION.  IF THIS JUMP IS DELETED THE DEBUGGING TOOLS BECOME ACTIVE.
ALSO, THE EXIT SECTION IS SKIPED AND CVT10 RUNS DIRECTLY UNDER
SNOBOL.  TO USE DEBUGGING TOOLS:
		1. DELETE THE JUMP TO 'FILBEG'.
		2. .R SYS:SNOBOL
		3. *,CVT10=CVT10	(GIVES A LISTING FILE)

<COMMAND>		<FUNCTION>

MTV		GIVE A VARIABLE NAME AND THEN A PATTERN NAME
		AND THE VARIABLE IS MATCHED AGAINST THE PATTERN.
		USED TO WALK THROUGH A TRANSLATION.

MTL		GIVE A LITERAL ('LOCAL X,Y;') AND THEN A PATTERN.
		THE LITERAL IS MATCHED AGAINST THE PATTERN, AND
		SUCESS OR FAILURE IS REPORTED, THE PATTERN
		VARIABLES ARE SET AND CAN EXAMINED USING LOOK.

LOOK		GIVE A VARIABLE NAME AND ITS VALUE IS DISPLAYED.

NODEBUG		STARTS THE CVT10 RUNNING, STOPS DEBUGGING

<CRLF>		PRINT OUT THE AVAILABLE COMMANDS
	<EXAMPLE OF ADDING A NEW TRANSLATION>

GOAL:	WHENEVER 'BCD10' IS SEEN MAKE IT '%BCD10'

LOGIC:	THIS IS A KEYWORD TRANSLATION, LOOK FOR THE
	KEYWORD SECTION OF CVT10.

ACTION:	ADD TO THE LIST OF KEYWORDS ('KEYWORD') 'BCD10'.
	INCREASE 'NUM.KW' BY ONE. (NUMBER OF KEYWORDS)
	EXTEND THE 'NEW.KW' TABLE:
		NEW.KW<'BCD10'> = '%BCD_10'

	EXTEND THE 'RTERM' TABLE:	(RIGHT SIDE TERMINATOR)
		RTERM<'BCD16>'> = LTERM	(LTERM = NOT ANY ALPHAS)
					(SO BCD102 IS NOT MATCHED)

REMAKE:	USING THE PROCEEDURE ABOVE, MAKE A NEW COPY OF CVT10.HGH
	AND CVT10.LOW.  THE HGH AND LOW ARE MADE SO THAT ALL OF
	CVT10'S PATTERNS (1/3 OF THE PROGRAM) DO NOT HAVE TO BE
	REINTERPRETTED EACH TIME THE PROGRAM IS RUN.


		<ADDING A TRANSFORMATION>

GOAL:	ALLOW FOR A 'FLOATING' DECLARATION:
	FLOATING MYVEC X[2]; -> FLOATING
				    X:	MYVEC[2];

LOGIC:	NOTE THAT THIS IS JUST LIKE AN OWN OR LOCAL DECLARATION,
	IT SHOULD BE TREATED AS AN 'NDEC'.

ACTION:	'ALL.TRNS' SHOULD HAVE 'FLOATING' AS AN ALTERNATIVE.
	'DECNAME' IS THE 'NDEC' SUBSET OF 'ALL.TRNS' AND SO
	'FLOATING' SHOULD BE ADDED TO THE 'DECNAME' LIST.

	CHANGE THE 'TRNTAB' TABLE DECLARATION TO MAKE 'TRNTAB'
	A ONE ELEMENT LARGER TABLE.  THEN 'FLOATING' HAS TO
	BE ADDED TO THE TABLE: TRNTAB<'FLOATING'> = 'NDEC'.
	THAT IS ALL, NOW 'FLOATING' WILL BE TRANSLATED.


		<END OF CVT10 DOCUMENTATION>

